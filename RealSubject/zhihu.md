### 1. Vue 中的watch侦听属性和computed计算属性有什么区别?
(1) 从属性名上来看: computed是计算属性, 是依赖于其他的属性计算出来的值; watch是侦听属性, 是监听某个属性的变化, 然后执行相关的函数。<br>
(2) 从实现上来看: computed的值在getter执行之后是会缓存的, 只有在依赖的属性的值发生改变之后, 下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听值变化时, 都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。<br>
(3) watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。<br>
(4) watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。

### 2. 为什么在vue的组件中，data要用function返回对象呢？
官方回答：当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。<br>
个人理解：如果不要function return返回个对象的话,那同一个组件的每个实例的 data 存的都是同一个地址, 其中一个data中的某个值发生变化, 其他实例的数据也会发生变化。用function 返回一个对象实例就想当于声明了一个新的变量, 相互独立, 就不会发生前面说的问题。

### 3. HTTP状态码你了解哪些?
- **1XX 消息** (代表请求已被接受, 需要继续处理。这类响应是临时响应, 只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。)
  - **100 Continue**<br>
    客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。
  - **101 Switching Protocols**<br>
    服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。<br>
    只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。
  - **102 Processing**<br>
    由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
- **2XX 成功** (这一类型的状态码，代表请求已成功被服务器接收、理解、并接受)
  - **200 OK**<br>
    请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。
  - **201 Created** <br>
    请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。
- **3XX 重定向** (这类状态码代表需要客户端采取进一步的操作才能完成请求。)
  - **302 Move temporarily**<br>
    请求的资源临时从不同的 URI响应请求。
  - **303 See Other**<br>
    对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。
  - **304 Not Modified**<br>
    如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。
- **4XX 请求错误** (这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理)
  - **400 Bad Request**<br>
    1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>
    2、请求参数有误。
  - **401 Unauthorized**<br>
    当前请求需要用户验证。
  - **402 Payment Required**
    该状态码是为了将来可能的需求而预留的。
  - **403 Forbidden**<br>
    服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交
  - **405 Method Not Allowed**<br>
    请求行中指定的请求方法不能被用于请求相应的资源
  - **422 Unprocessable Entity**<br>
    请求格式正确，但是由于含有语义错误，无法响应。
- **5XX 服务器错误** (这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理)
  - **500 Internal Server Error**<br>
    服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
  - **501 Not Implemented**<br>
    服务器不支持当前请求所需要的某个功能。
  - **502 Bad Gateway**<br>
    作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
  - **503 Service Unavailable**<br>
    由于临时的服务器维护或者过载，服务器当前无法处理请求。
  - **504 Gateway Timeout**<br>
    作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
  - **505 HTTP Version Not Supported**<br>
    服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。

### 4. 手写一个ajax
```javascript
  let xml = new XMLHttpRequest()
  xml.open(Method, url, boolean)
  xml.send()
  xml.onreadystatechange = function() {
    if (xml.readystate === 4) {
      if (xml.status === '200') {
        console.log(xml.responseText)
      }
    }
  }
```
1. **readstate有哪些状态？**<br>
**0** - (未初始化) 还没有开始调用send()方法<br>
**1** - (载入) 已经调用send()方法, 正在发送请求<br>
**2** - (载入完成) send() 方法执行完成, 已经接受到全部响应内容<br>
**3** - (交互) 正在解析响应内容<br>
**4** - (完成) 响应内容解析完成, 可以在客户端调用了
2. **status 有哪些状态？**<br>
状态和上述的HTTP状态码一样
3. **open()方法里面带的第三个参数是用来做什么的？**<br>
第三个参数指定是否使用异步，默认是true，所以不用写。千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。


